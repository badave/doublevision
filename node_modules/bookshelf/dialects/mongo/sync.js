// Sync
// ---------------
var _       = require('lodash');
var Promise = require('../base/promise');

// Sync is the dispatcher for any database queries,
// taking the "syncing" `model` or `collection` being queried, along with
// a hash of options that are used in the various query methods.
// The passed in db is shared with model, and is Knex or Mongo ('mongo-gyro' npm)
var Sync = function(syncing, options) {
  options || (options = {});
  this.db      = syncing.db;
  this.options = options;
  this.query   = this.options.query || _.result(syncing, "query");
  delete this.options.query;
  this.syncing = syncing;
  // if (options.transacting) this.query.transacting(options.transacting);
};

_.extend(Sync.prototype, {

  // Select the first item to match a query from the database - only used by models.
  findOne: Promise.method(function() {
    if(!this.db) {
      throw new Error("Database required: add a db to " + _.result(this.syncing, 'tableName'));
    }

    var options = this.options;
    var query = this.query || this.syncing.format(_.extend(Object.create(null), this.syncing.attributes));

    return Promise
      .bind(this)
      .tap(function() {
        return this.syncing.triggerThen('fetching', this.syncing, query, options);
      }).then(function() {
        return this.db.findOne(_.result(this.syncing, "tableName"), query);
      });
  }),

  // Performs a findCursor and then converts to an Array
  find: Promise.method(function() {
    if(!this.db) {
      throw new Error("Database required: add a db to " + _.result(this.syncing, 'tableName'));
    }

    var query = this.query;
    var syncing = this.syncing;
    var options = this.options;//, relatedData = this.syncing.relatedData;

    // Trigger a `fetching` event on the model, and then select the appropriate columns.
    return Promise
      .bind(this)
      .then(function() {
        return this.syncing.triggerThen('fetching', this.syncing, query, options);
      })
      .then(function() {
        return this.db.findCursor(_.result(syncing, "tableName"), query, options);
      })
      .then(function(cursor) {
        // saves cursor in case we want to pull total out of it later of the sync object
        this.cursor = cursor;
        return cursor.toArrayAsync();
      });
  }),

  count: Promise.method(function() {
    if(!this.db) {
      throw new Error("Database required: add a db to " + _.result(this.syncing, 'tableName'));
    }

    var query = this.query;
    var syncing = this.syncing;
    var options = this.options;//, relatedData = this.syncing.relatedData;

    // Trigger a `fetching` event on the model, and then select the appropriate columns.
    return Promise
      .bind(this)
      .then(function() {
        return this.syncing.triggerThen('fetching', this.syncing, query, options);
      })
      .then(function() {
        return this.db.count(_.result(syncing, "tableName"), query, options);
      });
  }),

  // Issues an `insert` command on the query - only used by models.
  insert: function() {
    if(!this.db) {
      throw new Error("Database required: add a db to " + _.result(this.syncing, 'tableName'));
    }

    var syncing = this.syncing;
    return this.db
      .insert(_.result(syncing, "tableName"), syncing.format(_.extend(Object.create(null), syncing.attributes)), this.options);
  },

  // Issues an `update` command on the query - only used by models.
  update: function(attrs, options) {
    if(!this.db) {
      throw new Error("Database required: add a db to " + _.result(this.syncing, 'tableName'));
    }

    var syncing = this.syncing;
    options || (options = {});
    var query = this.query;

    if (syncing.id != null) {
      query[syncing.idAttribute] = syncing.id;
    }

    if (_.isUndefined(query) || _.isNull(query)) {
      throw new Error('A model cannot be updated without a "query" clause or an idAttribute.');
    }

    var obj;
    if(options.patch) {
      obj = { 
        "$set": syncing.format(_.extend(Object.create(null), attrs))
      };
      delete options.patch;
    } else {
      obj = attrs;
    }

    return this.db
      .findAndModify(_.result(syncing, "tableName"), query, obj, this.options);
  },

  // Issues a `delete` command on the query.
  del: Promise.method(function() {
    var syncing = this.syncing;
    
    if(!this.db) {
      throw new Error("Database required: add a db to " + _.result(this.syncing, 'tableName'));
    }

    var query = this.query || this.syncing.format(_.extend(Object.create(null), this.syncing.attributes));
    return this.db.remove(_.result(syncing, "tableName"), query, this.options);
  })

});

module.exports = Sync;