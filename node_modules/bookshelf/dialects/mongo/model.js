// Model
// ---------------
var _             = require('lodash');

var Sync          = require('./sync');
var Helpers       = require('./helpers');

var ModelBase = require('../base/model');
var Promise   = require('../base/promise');

module.exports = ModelBase.extend({
  // MongoDB uses _id as it's idAttribute
  idAttribute: "_id",

  // Fetch a model based on the currently set attributes,
  // returning a model to the callback, along with any options.
  // Returns a deferred promise through the `Bookshelf.Sync`.
  // If `{require: true}` is set as an option, the fetch is considered
  // a failure if the model comes up blank.
  // 
  // To make a certain query, it's format is simply 
  //  model.fetch({ 
  //    query: { 
  //      email: ""
  //    }
  //  });
  fetch: Promise.method(function(options) {
    options = options ? _.clone(options) : {};

    var sync = this.sync(options);

    // Run the `first` call on the `sync` object to fetch a single model.
    return Promise.bind(this)
      .then(function() {
        return sync.findOne();
      })
      // Jump the rest of the chain if the response doesn't exist...
      .then(function(response) {
        if (!response || _.isEmpty(response)) {
          if (options.require) throw new Error('EmptyResponse');
          return Promise.reject(null);
        }
        return response;
      })
      // Now, load all of the data into the model as necessary.
      .tap(this._handleResponse)
      .then(function() {
        return this;
      })
      .caught(function(err) {
        throw err;
      });

    return sync.tap(function(response) {
      return this.triggerThen('fetched', this, response, options);
    })
    .yield(this)
    .caught(function(err) {
      if (err === null) return err;
      throw err;
    });

  }),

  // Sets and saves the hash of model attributes, triggering
  // a "creating" or "updating" event on the model, as well as a "saving" event,
  // to bind listeners for any necessary validation, logging, etc.
  // If an error is thrown during these events, the model will not be saved.
  save: Promise.method(function(key, val, options) {
    var attrs;

    // Handle both `"key", value` and `{key: value}` -style arguments.
    if (key == null || typeof key === "object") {
      attrs = key || {};
      options = val || {};
    } else {
      (attrs = {})[key] = val;
      options = options ? _.clone(options) : {};
    }

    return Promise.bind(this).then(function() {
      return this.isNew(options);
    }).then(function(isNew) {

      // If the model has timestamp columns,
      // set them as attributes on the model, even
      // if the "patch" option is specified.
      if (this.hasTimestamps) _.extend(attrs, this.timestamp(options));

      // Determine whether the model is new, based on whether the model has an `idAttribute` or not.
      var method = options.method || (options.method = isNew ? 'insert' : 'update');
      var vals = attrs;

      // If the object is being created, we merge any defaults here
      // rather than during object creation.
      if (method === 'insert' || options.defaults) {
        var defaults = _.result(this, 'defaults');
        if (defaults) {
          vals = _.extend({}, defaults, this.attributes, vals);
        }
      }

      // Set the attributes on the model.
      this.set(vals, {silent: true});

      var sync = this.sync(options);
      options.query = sync.query;

      return Promise.all([
        this.triggerThen((method === 'insert' ? 'creating' : 'updating'), this, attrs, options),
        this.triggerThen('saving', this, attrs, options)
      ])
      .bind(this)
      .then(function() {
        return sync[options.method](method === 'update' && options.patch ? attrs : this.attributes, options);
      })
      .then(function(resp) {
        // After a successful database save, the id is updated if the model was created
        if (method === 'insert' && resp) {
          this.attributes[this.idAttribute] = this[this.idAttribute] = resp[0][this.idAttribute];
        }

        // In case we need to reference the `previousAttributes` for the this
        // in the following event handlers.
        options.previousAttributes = this._previousAttributes;
        // update all values
        this.set(resp[0], {silent: true});

        return Promise.all([
          this.triggerThen((method === 'insert' ? 'created' : 'updated'), this, resp, options),
          this.triggerThen('saved', this, resp, options)
        ]);

      });

    }).yield(this);
  }),

  // Returns an instance of the query builder.
  query: function() {
    return Helpers.query(this, _.toArray(arguments));
  },

  // Creates and returns a new `Sync` instance.
  sync: function(options) {
    return new Sync(this, options);
  },

  // Handles the response data for the model, returning from the model's fetch call.
  _handleResponse: function(response) {
    this.set(this.parse(response), {silent: true});
  }

});