var _ = require('lodash');
_.str = require('underscore.string');

var Promise = global.testPromise;
var equal = require('assert').equal;
var deepEqual = require('assert').deepEqual;

module.exports = function(Bookshelf) {

  describe('Model', function() {
    var Backbone  = require('backbone');
    var Models    = require('../helpers/objects')(Bookshelf).Models;

    var stubSync = {
      first:  function() { return Promise.resolve({}); },
      select: function() { return Promise.resolve({}); },
      insert: function() { return Promise.resolve({}); },
      update: function() { return Promise.resolve({}); },
      del:    function() { return Promise.resolve({}); }
    };

    describe('extend/constructor/initialize', function() {

      var User = Bookshelf.Model.extend({
        idAttribute: 'user_id',
        getData: function() { return 'test'; }
      }, {
        classMethod: function() { return 'test'; }
      });

      var SubUser = User.extend({
        otherMethod: function() { return this.getData(); }
      }, {
        classMethod2: function() { return 'test2'; }
      });

      it('can be extended', function() {
        var user = new User();
        var subUser = new SubUser();
        expect(user.idAttribute).to.equal('user_id');
        expect(user.getData()).to.equal('test');
        expect(subUser.otherMethod()).to.equal('test');
        expect(User.classMethod()).to.equal('test');
        expect(SubUser.classMethod()).to.equal('test');
        expect(SubUser.classMethod2()).to.equal('test2');
      });

      it('accepts a custom `constructor` property', function() {
        var User = Bookshelf.Model.extend({
          constructor: function() {
            this.item = 'test';
            Bookshelf.Model.apply(this, arguments);
          }
        });
        equal(new User().item, 'test');
      });


      describe('forge', function() {

        it('should create a new model instance', function() {
          var User = Bookshelf.Model.extend({
            tableName: 'users'
          });
          var user = User.forge();
          equal(user.tableName, 'users');
        });

      });


      describe('id, idAttribute', function() {

        it('should attach the id as a property on the model', function() {
          var test = new Bookshelf.Model({_id: 1});
          equal(test.id, (1));
        });

        it('should reference idAttribute as the key for model.id', function() {
          var Test = Bookshelf.Model.extend({
            idAttribute: '_id'
          });
          var test2 = new Test({_id: 2});
          equal(test2.id, (2));
        });

      });


      describe('get', function() {

        it('should use the same get method as the Backbone library', function() {
          var attached = ['get'];
          _.each(attached, function(item) {
            deepEqual(Bookshelf.Model.prototype[item], Backbone.Model.prototype[item]);
          });
        });

      });


      describe('toJSON', function() {

        it('includes the idAttribute in the hash', function() {
          var m = new (Bookshelf.Model.extend({
            idAttribute: '_id'
          }))({'_id': 1, 'name': 'Joe'});
          deepEqual(m.toJSON(), {'_id': 1, 'name': 'Joe'});
        });

        it('includes the relations loaded on the model, unless {shallow: true} is passed.', function() {
          var m = new Bookshelf.Model({id: 1, name: 'Test'});
          m.relations = {someList: new Bookshelf.Collection([{id:1}, {id:2}])};
          var json = m.toJSON();
          deepEqual(_.keys(json), ['id', 'name', 'someList']);
          equal(json.someList.length, 2);
          var shallow = m.toJSON({shallow:true});
          deepEqual(_.keys(shallow), ['id', 'name']);
        });
      });


      describe('save', function() {

        var Site = Models.Site;

        it('saves a new object', function() {
          var site = new Site({name: 'Fourth Site ' + new Date().getTime()});

          return site.save().then(function(m) {
            equal(m.id, site.id);
            var sameSite = new Site({name: site.get('name')});
            return sameSite.fetch();
          })
          .then(function(model) {
            equal(site.id, model.id);
            equal(model.get('name'), site.get('name'));
          });
        });

        it('updates an existing object', function() {
          var site = new Site({name: 'Fourth Site ' + new Date().getTime()});

          return site.save().then(function() {
              site.set("name", site.get('name') + " Updated");
              return site.save();
            })
            .then(function() {
              var sameSite = new Site({name: site.get("name")});

              return sameSite.fetch();
            })
            .then(function(sameSite) {
              equal(sameSite.id, site.id);
              equal(sameSite.get('name'), site.get("name"));
            });
        });

        it('allows passing a method to save, to call insert or update explicitly', function() {
          var site = new Site({name: 'Fifth site, explicity created'});
          return site.save(null, {method: 'insert'})
          .then(function() {
            var Sites = Bookshelf.Collection.extend({
              model: Site,
              db: site.db
            });
            return new Sites().fetch({ query: { name: site.get('name') }});
          })
          .then(function(c) {
            equal(c.last().get('name'), 'Fifth site, explicity created');
          });
        });

        it('allows {patch: true} as an option for only updating passed data', function() {

          var user = new Bookshelf.Model({first_name: 'Testing'}, {tableName: 'users'});

          return user
            .save({bio: 'Short user bio'}, {patch: true})
            .then(function(model) {
              equal(model.get('bio'), 'Short user bio');
              equal(model.get('first_name'), 'Testing');
              equal(model.id, user.id);
            });
        });

      });


      describe('parse', function() {

        var ParsedSite = Models.Site.extend({
          parse: function (attrs) {
            attrs.name = 'Test: ' + attrs.name;
            return attrs;
          }
        });

        it('parses the model attributes on fetch', function() {
          return new ParsedSite()
            .fetch()
            .then(function(model) {
              equal(model.get('name').indexOf('Test: '), 0);
            });
        });

        it('parses the model attributes on creation if {parse: true} is passed', function() {
          var one = new ParsedSite({name: 'Site'});
          equal(one.get('name'), 'Site');
          var two = new ParsedSite({name: 'Site'}, {parse: true});
          equal(two.get('name'), 'Test: Site');
        });

      });

      describe('format', function() {

        // TODO: better way to test this.
        it('calls format when saving', function() {

          var M = Backbone.Model.extend({
            tableName: 'test',
            format: function(attrs) {
              return _.reduce(attrs, function(memo, val, key) {
                memo[_.str.underscored(key)] = val;
                return memo;
              }, {});
            }
          });

          var m = new M({firstName: 'Tim', lastName: 'G'});
          m.sync = function() {
            var data = this.format(_.extend({}, this.attributes));
            equal(data.first_name, 'Tim');
            equal(data.last_name, 'G');
            return stubSync;
          };
          return m.save();

        });

      });

    });
  });

};